//#include<iostream>
//using namespace std;
///*
//整数拆分1<=N<=1000000，输出f(n)%1000000000
//解法一
//这道题其实是一个完全背包求恰装满背包时的 方案总数 问题.
//是因为每一个拆分必须是1,2,4,2^3,...2^19 (n最大为10^6),
//所以对于一个整数n,问有多少种拆分,就相当于现在有20种物品,第i种物品的花费是2^(i-1),
//每一种可以重复取, 问有多少种取法。
//dp[i][j]表示前i种物品装进容量为j的背包时最多多少种取法,分为第i件不取/取两种
//从而dp[i][j] = dp[i-1][j] + dp[i][j-a[i]],这里是要知道多少种取法，不是哪种取法装的最多
//
//解法二
//记f(n)为n的划分数，我们有递推公式：
//
//	f(2m + 1) = f(2m)，
//	f(2m) = f(2m - 1) + f(m)，
//	初始条件：f(1) = 1。
//对于N，分为两种情况：
//1) N为奇数(2m+1)，则每个拆分结果必然至少有一个1，因为只通过k个偶数无法组成奇数。
//所以f(2m+1) = f(2m)
//2) N为偶数(2m)，拆分同样分为两类：
//    a) 拆分结果包含1：所有的拆分数目为f(2m-1),同上。
//    b) 拆分结果不包含1：拆分数目为f(m)。 拆分结果不包含1,说明是拆分成了k个偶数，
//        那么对每一种拆分结果都除以2，并不会影响整体拆分的数目。
//        但是每个拆分结果的sum都变成了m，即每个2m的偶拆分都变成了m的拆分。
//        同样对m的每种拆分结果都乘以2，拆分结果的sum都变成了2m且不包含1。
//        即m的拆分和2m的偶拆分一一对应。
//*/
//void test1()//动态规划
//{
//    int n;
//    //构造物品重量2^0 - 2^19
//    int* a = new int[20];
//    for (int i = 0; i < 20; i++)
//        a[i] = (1 << i);
//
//    while (cin >> n)
//    {
//        //dp[j]表示放入第i个物品时，剩下的j空间可以达到的最大重量
//        int* dp = new int[n + 1];
//        dp[0] = 1;
//        for (int t = 1; t <= n; t++)
//            dp[t] = 0;
//
//        for (int i = 0; i < 20; i++)
//        {
//            for (int j = a[i]; j <= n; j++)
//            {
//                dp[j] += dp[j - a[i]];
//                dp[j] %= 1000000000;
//            }
//        }
//        cout << dp[n] << endl;
//        delete[] dp;
//    }
//}
//void test2()//公式法
//{
//    int n;
//    while (cin >> n)
//    {
//        int* result = new int[n + 1];
//        result[0] = result[1] = 1;
//        for (int i = 2; i <= n; ++i)
//        {
//            if (i % 2 == 0)
//                result[i] = (result[i - 1] + result[i / 2]) % 1000000000;
//            else
//                result[i] = result[i - 1] % 1000000000;
//        }
//        cout << result[n] << endl;
//        delete[] result;
//    }
//}
//int main()
//{
//    test1();
//    //test2();
//    return 0;
//}