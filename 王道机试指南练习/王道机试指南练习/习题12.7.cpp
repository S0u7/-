//#include<iostream>
//using namespace std;
///*放苹果：把 M 个同样的苹果放在 N 个同样的盘子里，顺序无关。1≤m, n≤20
//允许有的盘子空着不放，问共有多少种不同的分法？
//苹果 < 盘子 = 去掉一个盘子的分法
//苹果 = 盘子 = 有空盘子,去掉空盘子的分法 + 1(每个盘子一个的分法)
//苹果 > 盘子，有两种情况
// 1、每个盘子都有苹果，= 每个盘子都拿掉一个苹果后的分法
// 2、有空盘子(至少一个)，= 去掉空盘子后的分法  相加*/
//int main()
//{
//	int m, n;
//	while (cin>>m>>n)
//	{
//        int** dp = new int* [m + 1];//dp[i][j]表示i个苹果放在j个盘子中时，有多少种分法
//        for (int i = 1; i <= m; i++)
//        {
//            dp[i] = new int[n + 1];
//            //base case只有一个盘子时或只有一个水果时，只有一种分法
//            dp[i][1] = 1;
//            for (int j = 1; j <= n; j++)
//                dp[1][j] = 1;
//        }
//        for (int i = 1; i <= m; i++)
//        {
//            for (int j = 2; j <= n; j++)
//            {
//                if (i < j) //苹果比盘子少时，等于去掉一个盘子的分法
//                    dp[i][j] = dp[i][j - 1];
//                //苹果和盘子一样多时，等于有空盘子去掉空盘子的分法+每个盘子一个的分法
//                else if (i == j) 
//                    dp[i][j] = dp[i][j - 1] + 1;
//                /*苹果比盘子多时，有两种情况
//                1、每个盘子都有苹果，那就等于每个盘子都拿掉一个苹果后的分法数
//                2、有空盘子(至少一个)，就等于去掉空盘子后的分法*/
//                else 
//                    dp[i][j] = dp[i - j][j] + dp[i][j - 1];
//            }
//        }
//        cout << dp[m][n] << endl;
//        for (int i = 1; i <= m; i++)
//            delete[] dp[i];
//        delete[] dp;
//	}
//	return 0;
//}